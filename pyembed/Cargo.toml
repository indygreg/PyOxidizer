[package]
name = "pyembed"
# Remember to keep this version string in sync with the PYEMBED_CRATE_VERSION
# constant in pyoxidizer's environment.rs. The release automation should do
# this automatically.
version = "0.18.0-pre"
authors = ["Gregory Szorc <gregory.szorc@gmail.com>"]
edition = "2018"
license = "Python-2.0 OR MPL-2.0"
description = "Embed a Python interpreter"
homepage = "https://github.com/indygreg/PyOxidizer"
repository = "https://github.com/indygreg/PyOxidizer.git"
build = "build.rs"

# This line is a lie. It says we are emitting build annotations that
# we link against the specified library. However, we do no such thing! Rather
# we rely on the presence of this line to cause cargo to set `DEP_*`
# environment variables in dependent crates' build scripts. PyOxidizer's
# Rust projects rely on this to pass metadata about the PyOxidizer build
# through Cargo. Essentially, the PyOxidizer build modes (controlled via
# cargo feature flags) cause our build script to emit metadata, which will
# be consumed via `DEP_*` environment variables in downstream build
# scripts. It is a bit hacky. But it gets the job done.
links = "pyembed"

[dependencies]
# Update documentation in lib.rs when new dependencies are added.
anyhow = "1.0"
cpython = "0.6.0"
dunce = "1.0"
jemalloc-sys = { version = "0.3", optional = true }
memmap = "0.7"
once_cell = "1.7"
python3-sys = "0.6.0"

[dependencies.snmalloc-sys]
version = "0.2"
features = ["build_cc"]
optional = true

[dependencies.libmimalloc-sys]
version = "0.1"
features = [
    "extended",
    "local_dynamic_tls",
    "override",
]
optional = true

[dependencies.pyo3]
version = "0.14.5"
default-features = false
features = ["macros"]

[dependencies.python-packed-resources]
version = "0.8.0-pre"
path = "../python-packed-resources"

[dependencies.python-packaging]
version = "0.11.0-pre"
path = "../python-packaging"
default-features = false

[dependencies.tugger-file-manifest]
version = "0.6.0-pre"
path = "../tugger-file-manifest"

[target.'cfg(windows)'.dependencies]
memory-module-sys = "0.3"
winapi = { version = "0.3", features = ["libloaderapi", "memoryapi", "minwindef"] }

[build-dependencies]
pyo3-build-config = "0.14.5"

[dev-dependencies]
pathdiff = "0.2"
rusty-fork = "0.3"

[features]
default = ["build-mode-default"]
allocator-jemalloc = ["jemalloc-sys"]
allocator-mimalloc = ["libmimalloc-sys"]
allocator-snmalloc = ["snmalloc-sys"]

# The default build mode.
#
# This crate links against whatever Python is picked up by the cpython crate
# using its default link semantics.
build-mode-default = [
    "cpython-link-default",
]

# Build this crate in isolation, without using PyOxidizer.
build-mode-standalone = [
    "cpython-link-unresolved-static",
]

# Build this crate by executing a `pyoxidizer` executable to build
# required artifacts.
build-mode-pyoxidizer-exe = []

# Build this crate by reusing artifacts generated by `pyoxidizer` out-of-band.
# In this mode, the PYOXIDIZER_ARTIFACT_DIR environment variable can refer
# to the directory containing build artifacts produced by `pyoxidizer`. If not
# set, OUT_DIR will be used.
build-mode-prebuilt-artifacts = []

build-mode-extension-module = [
    "cpython/extension-module",
]

# Build mode for running tests.
build-mode-test = [
    "cpython-link-default",
]

# Build the cpython crate in unresolved static mode (we will provide a static
# library to link against).
cpython-link-unresolved-static = [
    "cpython/py-link-mode-unresolved-static",
    "cpython/python3-sys",
    "cpython/no-auto-initialize",
]

# Build the cpython with default link mode control. It will pick up the prebuilt
# libpython from PYTHON_SYS_EXECUTABLE or from PATH.
cpython-link-default = [
    "cpython/py-link-mode-default",
    "cpython/python3-sys",
    "cpython/no-auto-initialize",
]
